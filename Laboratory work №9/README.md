# Лабораторная работа №9 Синхронизация потоков с помощью семафоров

**Цель работы**: Научиться организовывать синхронизацию нескольких параллельно выполняющихся потоков используя семафоры.

## Задание

Реализовать многопоточные, приложения моделирующие ситуации, описанные ниже. Для синхронизации потоков использовать
семафоры.

**Вариант №6**: Есть три курильщика и один слуга. Курильщики непрерывно курят сигары беря их из общей коробки, если
коробка пуста курильщики отдыхают. Если коробка полностью не заполнена, слуга периодически докладывает в нее новые
сигары, но не больше, чем она может вместить.

## Теоретическая часть

Семафоры позволяют ограничить количество потоков обращающихся к объекту ожидания. Если количество обращающихся к
семафору потоков превышает допустимое, то эти новые потоки приостанавливаются. При отключении присоединённых к семафору
потоков, приостановленные потоки подключаются к семафору и продолжают своё выполнение.

Семафоры обычно используются для синхронизации потоков, которые обращаются к набору равнозначных общих ресурсов,
например очередь, списки и т.п.

Классический примером использования семафора является использование, при котором потоки разбирают элементы общей
очереди. Если очередь пуста, то потоки выполняющие новые запросы приостанавливаются, до появления новых элементов. Для
учёта элементов в очереди используется семафор.

Семафор не имеет владельца. Тем самым любой поток может увеличить или уменьшить счётчик семафора. Семафор является
экземпляром класса `Semaphore` из пространства имён `System.Threading`.

Конструкторы класса `Semaphore`:

- `Semaphore(int initialCount, int maximumCount)`
  - `initialCount` задаёт начальное количество потоков, которые могут обращаться к семафору;
  - `maximumCount` указывает на максимальное количество потоков, которые имеют общий доступ к ресурсам.
- `Semaphore(int initialCount, int maximumCount, string? name)` - создаёт именованный поток, который может быть доступен
  из других процессов
  - `name` задаёт имя семафора.
- `Semaphore(int initialCount, int maximumCount, string? name, out bool createdNew)` - позволяет создать именованный
  поток и получить обратную связь (успешно/уже создан)
  - `createdNew` - возвращает `true`, если семафор был создан, иначе `false`.

Методы класса `Semaphore`:

- `WaitOne()` - ставит поток в очередь на доступ к семафору;
- `Release()` - освобождает семафор.

Пример:

В приведенном примере описывается многопоточное приложение, в котором поток-писатель на каждой итерации цикла помещает в
очередь случайное число, а потоки-читатели соответственно извлекают числа из очереди. Размер очереди ограничен тремя
элементами. Если очередь полностью заполнена, поток-писатель засыпает. При заполнении очереди активизируется ровно
столько потоков-читателей, сколько элементов в данный момент находится в очереди. Например, если в очереди на данный
момент времени находится два числа, «проснутся» два потока-читателя, третий будет «спать». Если очередь пуста, засыпают
потоки – читатели.

```csharp
using System;
using System.IO;
using System.Threading;

class Program
{
    public static int index = 0;
    public static int[] data = new int[3];
    public static Random random = new();
    public static Thread writerThread = new Thread(WriterThreadMethod),
        firstReaderThread = new Thread(ReaderThreadMethod) { Name = "Первый поток" },
        secondReaderThread = new Thread(ReaderThreadMethod) { Name = "Второй поток" },
        thirdReaderThread = new Thread(ReaderThreadMethod) { Name = "Третий поток" };

    /// <summary>
    /// Семафор защищающий очередь от переполнения.
    /// На момент создания счётчик свободных элементов равен 3.
    /// </summary>
    public static Semaphore firstSemaphore = new(3, 3);

    /// <summary>
    /// Семафор обеспечивающий доступ к очереди для потоков читателей.
    /// На момент создания счётчик ресурсов равен 0, то есть очередь пуста.
    /// </summary>
    public static Semaphore secondSemaphore = new(0, 3);

    public static void Main()
    {
        writerThread.Start();
        firstReaderThread.Start();
        secondReaderThread.Start();
        thirdReaderThread.Start();

        writerThread.Join();
    }

    public static void Put(int number)
    {
        lock (typeof(Program))
        {
            index++;
            data[index - 1] = number;
        }
    }

    public static int Get()
    {
        lock (typeof(Program))
        {
            var result = data[index - 1];
            index--;
            return result;
        }
    }

    public static void WriterThreadMethod()
    {
        while (true)
        {
            // Если очередь полна, то поток для записи засыпает, пока не освободится семафор
            firstSemaphore.WaitOne();

            // Добавление случайного числа в очередь
            Put(random.Next(100));

            // Увеличиваем счётчик ресурсов второго семафора
            secondSemaphore.Release();
        }
    }

    public static void ReaderThreadMethod()
    {
        while (true)
        {
            // Если очередь пуста, то поток засыпает
            secondSemaphore.WaitOne();
            Console.WriteLine($"[{Thread.CurrentThread.Name}]: {Get()}");
            Thread.Sleep(1000);

            // увеличиваем счётчик текущих ресурсов первого семафора, чтобы потоки выполняющие
            // чтение могли продолжить свою работу
            firstSemaphore.Release();
        }
    }
}
```