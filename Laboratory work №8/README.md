# Лабораторная работа №8 Синхронизация потоков с помощью критических секций

**Цель работы**: Научиться организовывать синхронизацию нескольких параллельно выполняющихся потоков используя 
критические секции.

## Задание

Данная работа предполагает решение задачи организации взаимоисключающего доступа к разделяемому ресурсу с помощью 
критических секций. При выполнении задания необходимо выявить критические участки кода и защитить их с помощью 
критических секций.

**Вариант №6**: Напишите программу, в которой два потока работая параллельно, генерируют в цикле (50 итераций) некоторую
последовательность целых чисел. Полученные данные накапливаются в общем массиве размером 5 элементов. Причем, в один и 
тот же момент времени в массиве могут находиться данные, принадлежащие одному потоку. Всякий раз, после заполнения 
массива, тот поток, чьи данные находятся в массиве, должен просуммировать эти данные, вывести результат на экран и 
очистить массив.

## Теоретическая часть

Критическая секция гарантирует, что куски кода программы, огороженные ей, не будут выполняться одновременно. Так как она
не является объектом ядра, то программа не переходит в режим ядра для проверки занята ли секция. Тем самым она является 
более быстрой.

Отличия от мьютексов:

- Мьютексы могут быть использованы совместно разными потоками в разных процессах;
- Для критической секции не существует понятие таймаута, в отличие от мьютексов;
- В отличие от других объектов синхронизации, критические секции не представлены в виде отдельного класса, а встроены в 
- структуру .NET.

Для работы с критическими секциями в языке C# используется: `lock(expression) { code; }`. В качестве выражения 
указывается объект, который блокируется и доступ к нему имеет только один поток. Обычно используется `this` или 
`typeof(Class)` для защиты статических переменных или методов.

```csharp
using System;
using System.IO;
using System.Threading;
using static System.Net.Mime.MediaTypeNames;

class Program
{
    public static Random random = new();
    public static Thread firstThread, secondThread;
    
    public static void Main()
    {
        firstThread = new Thread(Do) { Name = "Первый поток" };
        secondThread = new Thread(Do) { Name = "Второй поток" };

        firstThread.Start();
        secondThread.Start();

        firstThread.Join();
        secondThread.Join();
        Console.ReadKey();
    }
    
    public static void Do()
    {
        for (int i = 0; i < 10; i++)
        {
            Thread.Sleep(random.Next(100));
            lock(typeof(Program))
            {
                File.AppendAllText(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) + @"\Downloads\data.txt", Thread.CurrentThread.Name + "\n\r");
                Console.WriteLine(Thread.CurrentThread.Name);
                Thread.Sleep(random.Next(100));
            }
        }
    }
}
```