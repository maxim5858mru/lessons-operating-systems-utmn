# Лабораторная работа №6 Синхронизация потоков с помощью событий

**Цель работы**: Научиться организовывать синхронизацию нескольких параллельно выполняющихся процессов или потоков используя события.

## Задание

Данная работа предполагает решение одной из классических задач синхронизации в операционной среде:

1. Реализация задачи «поставщик - потребитель»;
2. Реализация задачи «читатели - писатели». 

Требуется реализовать приложение - поставщик и приложение - потребитель или многопоточное приложение с потоком «поставщик» и потоком «потребитель». В некоторых случаях потребуется реализовать несколько потоков «поставщиков» или «потребителей». Для синхронизации потоков использовать объект ожидания – событие.

**Вариант №6**: Напишите программу, в которой первый поток в бесконечном цикле генерирует числа в диапазоне от 0 до 100 и выводит их на экран. Второй поток делит каждое число на 2 и дописывает полученные значения в текстовый файл. Для передачи данных от первого ко второму потоку использовать буфер в виде массива, размером 10 элементов.

## Теоретическая часть

### Управление потоками средствам WIN32 API

#### Функция ожидания

В традиционных WIN32 программах для сихронизации потоков используется средства WIN32 API. Функция ожидания позволяет потоку в любой момент приостановиться и ждать освобождения какого-либо объекта ядра.

```cpp
DWORD WaitForSingleObject(
	[in] HANDLE hHandle,
	[in] DWORD  dwMilliseconds
);
```

Аргументы:
- `hHandle` - идентифицирует объект ожидания ядра, поддерживающий состояния «свободен - занят»;
- `dwMilliseconds` - указывает, сколько времени поток готов ждать освобождения объекта. Если указанно конкретное значение, то по его истечении функция возвращает управление. Если указано значение `INFINITE`, то поток будет ждать освобождения объекта до тех пор, пока его не освободят.

Возвращаемые значения:
- `WAIT_OBJECT_0` - объект свободен;
- `WAIT_TIMEOUT` - заданое время истекло;
- `WAIT_FAILED` - были переданы неверные параметры, чтобы выяснить конкретную причину, можно вызвать функцию `GetLastError()`.

Функция `WaitForMultipleObject(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)` аналогична, но позволяет ждать освобождения нескольких объектов.

#### События

Является постейшим объектом сихронизации. Может принимать два состояния: свободен или занят. События бывают двух типов:
- **Manual-reset events**, со сбросом вручную. Позволяют возобновлять выполнение сразу нескольких потоков;
- **Auto-reset events**, с автосбросом. Позволяют возобновлять выполнение только одного потока.

Объекты - события обычно используют только в том случае, когда какой-то поток выполняет инициализацию, а затем сигнализирует другому потоку о готовности к его работе. Ненужные объекты событий следует закрывать методом `CloseHandle(HANDLE hObject)`.

Для управления состоянием событий используют следующие функции:
- `SetEvent(HANDLE hEvent)` - устанавливает событие в состояние «свободен»;
- `ResetEvent(HANDLE hEvent)` - устанавливает событие в состояние «занят»;
- `PulseEvent(HANDLE hEvent)` - освобождает событие и обратно переводит его в состояние «занят».

Когда ожидание события с автосбросом успешно завершается потоком, то событие автоматически переводится в состояние «занят», тем самым не нужно вызывать `ResetEvent(HANDLE hEvent)`. 

Если вызывается метод `PulseEvent(HANDLE hEvent)` для события со сбросом вручную, то любые потоки ждущие этот объект становятся планируемыми. При вызове этой функции к событию с автосбросом пробуждается только один из ждущих потоков. В случае если ни один из потоков не ждёт события с автосбросом, то вызов функции не даёт эффекта.

### Управления потоками средствами .NET

#### `AutoResetEvent`

Класс `AutoResetEvent` является потомком класса `EventWaitHandle` и представляет собой событие с автосбросом. Поток, которому необходимо дождаться наступления определённого события вызвает метод экземпляра `WaitOne()`. Если событие находится в состоянии «занят» (иначе говоря, в несигнальном состоянии), то поток блокируется до тех пор, пока событие не перейдёт в состояние «свободен». После этого один из ожидающих потоков проболжает работу, а событие автоматически переводится в состояние «занят». Если ожидающих потоков нет, то событие остаётся в «свободном» состоянии на неопределённое время.

#### `ManualResetEvent` и `ManualResetEventSlim`

Класс `ManualResetEvent` является потомком класса `EventWaitHandle` и представляет собой событие с ручным сбросом. Класс `ManualResetEventSlim` представляет собой упрощённую и более быструю версию, используемую в рамках одного процесса. В отличие от событий с автоматическим сбросом, событие с ручным сбросом в «свободном» состоянии остаётся в нём до вызова метода `Reset()`. При переходе в «свободное» состояние все ожидающие потоки освобождаются немедленно.

#### `EventWaitHandle`

Позволяет создавать именованные события, функционал которых повторяет функционал классов `AutoResetEvent` и `ManualResetEvent`, но позволяет использовать их в рамках синхронизации между процессами.

Пример:

Первый поток периодически заполняет массив. Когда массив заполняется, первый поток блокируется и просыпается второй поток, который выводит содержимое на экран и очищает массив. После этого первый поток продолжает работу.

```csharp
internal class Program
{
    private static int[] data;
    private static AutoResetEvent evenWriter;
    private static AutoResetEvent evenReader;

    static void Main(string[] args)
    {
        var reader = new Thread(ReaderThreadMethod);
        var writer = new Thread(WriterThreadMethod);
        data = new int[10];

        // Событие для записи создаётся изначально в свободном состоянии
        evenWriter = new AutoResetEvent(true);

        // Событие для записи создаётся изначально в несвободном 
        evenReader = new AutoResetEvent(false);

        reader.Start();
        writer.Start();

        reader.Join();
        writer.Join();
    }

    private static void WriterThreadMethod()
    {
        while (true)
        {
            // Приостановка потока
            evenWriter.WaitOne();
#if DEBUG
            Console.WriteLine("In WriterThreadMethod");
#endif

            for (int i = 0; i < data.Length; i++)
            {
                data[i] = i;
                Thread.Sleep(100);
            }

            // Освобождение события для второго потока, выполняющего чтение
            evenReader.Set();
        }
    }

    private static void ReaderThreadMethod()
    {
        while (true)
        {
            evenReader.WaitOne();
#if DEBUG
            Console.WriteLine("In ReaderThreadMethod");
#endif

            // Считывание значений и очистка массива
            string values = "";
            for (int i = 0; i < data.Length; i++)
            {
                values += data[i].ToString();
                data[i] = 0;
            }

            Console.WriteLine(values);

            // Освобождение события для первого потока, выполняющего запись
            evenWriter.Set();
        }
    }
}
```